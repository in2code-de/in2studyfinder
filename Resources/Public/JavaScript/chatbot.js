!function(t){var e={};function n(r){if(e[r])return e[r].exports;var o=e[r]={i:r,l:!1,exports:{}};return t[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}n.m=t,n.c=e,n.d=function(t,e,r){n.o(t,e)||Object.defineProperty(t,e,{enumerable:!0,get:r})},n.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},n.t=function(t,e){if(1&e&&(t=n(t)),8&e)return t;if(4&e&&"object"==typeof t&&t&&t.__esModule)return t;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:t}),2&e&&"string"!=typeof t)for(var o in t)n.d(r,o,function(e){return t[e]}.bind(null,o));return r},n.n=function(t){var e=t&&t.__esModule?function(){return t.default}:function(){return t};return n.d(e,"a",e),e},n.o=function(t,e){return Object.prototype.hasOwnProperty.call(t,e)},n.p="",n(n.s="./JavaScript/Frontend/chatbot.js")}({"./JavaScript/Frontend/chatbot.js":
/*!****************************************!*\
  !*** ./JavaScript/Frontend/chatbot.js ***!
  \****************************************/
/*! no exports provided */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _chatbotWidget_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chatbotWidget/index.js */ "./JavaScript/Frontend/chatbotWidget/index.js");\n\nvar chatbotWidgetElement = document.querySelector(\'[data-chatbot-container-widget]\');\nif (chatbotWidgetElement) {\n  var chatbot = new _chatbotWidget_index_js__WEBPACK_IMPORTED_MODULE_0__["default"](chatbotWidgetElement, true);\n  chatbot.init();\n}\nvar chatbotElement = document.querySelector(\'[data-chatbot-container]\');\nif (chatbotElement) {\n  var _chatbot = new _chatbotWidget_index_js__WEBPACK_IMPORTED_MODULE_0__["default"](chatbotElement, false);\n  _chatbot.init();\n}\n\n//# sourceURL=webpack:///./JavaScript/Frontend/chatbot.js?')},"./JavaScript/Frontend/chatbotWidget/index.js":
/*!****************************************************!*\
  !*** ./JavaScript/Frontend/chatbotWidget/index.js ***!
  \****************************************************/
/*! exports provided: default */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _ui_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ui.js */ "./JavaScript/Frontend/chatbotWidget/ui.js");\n/* harmony import */ var _messaging_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./messaging.js */ "./JavaScript/Frontend/chatbotWidget/messaging.js");\n/* harmony import */ var _position_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./position.js */ "./JavaScript/Frontend/chatbotWidget/position.js");\n/* harmony import */ var _storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./storage.js */ "./JavaScript/Frontend/chatbotWidget/storage.js");\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n// Main entry point for MistralChatbot\n\n\n\n\nvar MistralChatbot = /*#__PURE__*/function () {\n  function MistralChatbot(chatbotWidget, draggable) {\n    _classCallCheck(this, MistralChatbot);\n    this.chatbotWidget = chatbotWidget;\n    this.draggable = draggable;\n  }\n  _createClass(MistralChatbot, [{\n    key: "init",\n    value: function init() {\n      // Initialize components\n      this.storage = new _storage_js__WEBPACK_IMPORTED_MODULE_3__["Storage"]();\n      this.ui = new _ui_js__WEBPACK_IMPORTED_MODULE_0__["UI"](this.chatbotWidget);\n      this.messaging = new _messaging_js__WEBPACK_IMPORTED_MODULE_1__["Messaging"](this.chatbotWidget, this.ui);\n\n      // Setup components\n      this.ui.setupResizeHandler();\n      if (this.draggable) {\n        this.position = new _position_js__WEBPACK_IMPORTED_MODULE_2__["Position"](this.chatbotWidget, this.storage);\n        this.position.setupDraggable();\n        this.position.loadPosition();\n      }\n\n      // Load minimized state\n      var isMinimized = this.storage.loadMinimizedState();\n      if (isMinimized) {\n        this.chatbotWidget.classList.add(\'minimized\');\n        this.chatbotWidget.querySelector(\'[data-chatbot-toggle]\').textContent = \'+\';\n      }\n\n      // Bind events\n      this.bindEvents();\n    }\n  }, {\n    key: "bindEvents",\n    value: function bindEvents() {\n      var _this = this;\n      var that = this;\n      var sendBtn = this.chatbotWidget.querySelector(\'[data-chatbot-send]\');\n      var input = this.chatbotWidget.querySelector(\'[data-chatbot-input]\');\n      var toggle = this.chatbotWidget.querySelector(\'[data-chatbot-toggle]\');\n      var defaultPrompt = this.chatbotWidget.querySelector(\'[data-defaultprompt]\');\n      sendBtn.addEventListener(\'click\', function () {\n        var message = input.value.trim();\n        _this.messaging.sendMessage(message);\n      });\n      input.addEventListener(\'keypress\', function (e) {\n        if (e.key === \'Enter\' && !e.shiftKey) {\n          e.preventDefault();\n          var message = input.value.trim();\n          _this.messaging.sendMessage(message);\n        }\n      });\n      toggle.addEventListener(\'click\', function () {\n        var isMinimized = _this.ui.toggleChat();\n        _this.storage.saveMinimizedState(isMinimized);\n      });\n      defaultPrompt.addEventListener(\'click\', function (e) {\n        that.ui.hideDefaultPrompt();\n        input.value = e.target.innerHTML.trim();\n        that.ui.adjustTextareaHeight(input);\n      });\n    }\n  }]);\n  return MistralChatbot;\n}(); // Initialize chatbot when DOM is loaded\ndocument.addEventListener(\'DOMContentLoaded\', function () {\n  new MistralChatbot();\n});\n\n// Export the class for potential reuse\n/* harmony default export */ __webpack_exports__["default"] = (MistralChatbot);\n\n//# sourceURL=webpack:///./JavaScript/Frontend/chatbotWidget/index.js?')},"./JavaScript/Frontend/chatbotWidget/messaging.js":
/*!********************************************************!*\
  !*** ./JavaScript/Frontend/chatbotWidget/messaging.js ***!
  \********************************************************/
/*! exports provided: Messaging */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Messaging", function() { return Messaging; });\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\nfunction _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, ""); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: "normal", arg: fn.call(obj, arg) }; } catch (err) { return { type: "throw", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { ["next", "throw", "return"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if ("throw" !== record.type) { var result = record.arg, value = result.value; return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke("next", value, resolve, reject); }, function (err) { invoke("throw", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke("throw", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, "_invoke", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = "suspendedStart"; return function (method, arg) { if ("executing" === state) throw new Error("Generator is already running"); if ("completed" === state) { if ("throw" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) { if ("suspendedStart" === state) throw state = "completed", context.arg; context.dispatchException(context.arg); } else "return" === context.method && context.abrupt("return", context.arg); state = "executing"; var record = tryCatch(innerFn, self, context); if ("normal" === record.type) { if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var method = delegate.iterator[context.method]; if (undefined === method) { if (context.delegate = null, "throw" === context.method) { if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel; context.method = "throw", context.arg = new TypeError("The iterator does not provide a \'throw\' method"); } return ContinueSentinel; } var record = tryCatch(method, delegate.iterator, context.arg); if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = "normal", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: "root" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if ("function" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) { if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; } return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) { var ctor = "function" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, "toString", function () { return "[object Generator]"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) { keys.push(key); } return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) { "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); } }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if ("throw" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if ("root" === entry.tryLoc) return handle("end"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error("try statement without catch or finally"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if ("throw" === record.type) throw record.arg; return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, "catch": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if ("throw" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, "next" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n// Messaging Component for MistralChatbot\nvar Messaging = /*#__PURE__*/function () {\n  function Messaging(chatbotWidget, ui) {\n    _classCallCheck(this, Messaging);\n    this.chatbotWidget = chatbotWidget;\n    this.ui = ui;\n  }\n  _createClass(Messaging, [{\n    key: "sendMessage",\n    value: function () {\n      var _sendMessage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(message) {\n        var input, typingIndicator, response, data;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (message.trim()) {\n                  _context.next = 2;\n                  break;\n                }\n                return _context.abrupt("return");\n              case 2:\n                this.addMessage(message, \'user\');\n\n                // Reset textarea height after clearing\n                input = this.chatbotWidget.querySelector(\'[data-chatbot-input]\');\n                input.value = \'\';\n                input.style.height = \'auto\';\n                input.style.height = input.scrollHeight + \'px\';\n\n                // Show typing indicator\n                typingIndicator = this.showTypingIndicator(); // hide default prompt\n                this.ui.hideDefaultPrompt();\n                _context.prev = 9;\n                _context.next = 12;\n                return fetch(this.chatbotWidget.getAttribute(\'data-chatbot-url\'), {\n                  method: \'POST\',\n                  headers: {\n                    \'Content-Type\': \'application/json\'\n                  },\n                  body: JSON.stringify({\n                    message: message\n                  })\n                });\n              case 12:\n                response = _context.sent;\n                _context.next = 15;\n                return response.json();\n              case 15:\n                data = _context.sent;\n                // Remove typing indicator\n                this.removeTypingIndicator(typingIndicator);\n                if (data.success) {\n                  // Show message with typing effect\n                  this.addMessageWithTypingEffect(data.message, \'assistant\');\n                } else {\n                  this.addMessageWithTypingEffect(\'Entschuldigung, es gab einen Fehler.\', \'assistant\');\n                }\n                _context.next = 24;\n                break;\n              case 20:\n                _context.prev = 20;\n                _context.t0 = _context["catch"](9);\n                this.removeTypingIndicator(typingIndicator);\n                this.addMessageWithTypingEffect(\'Verbindungsfehler. Bitte versuchen Sie es später.\', \'assistant\');\n              case 24:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[9, 20]]);\n      }));\n      function sendMessage(_x) {\n        return _sendMessage.apply(this, arguments);\n      }\n      return sendMessage;\n    }()\n  }, {\n    key: "showTypingIndicator",\n    value: function showTypingIndicator() {\n      var messages = this.chatbotWidget.querySelector(\'[data-chatbot-messages]\');\n      var typingEl = document.createElement(\'div\');\n      typingEl.className = \'message assistant typing-indicator\';\n      typingEl.innerHTML = "\\n            <div class=\\"typing-dots\\">\\n                <span></span>\\n                <span></span>\\n                <span></span>\\n            </div>\\n        ";\n      messages.appendChild(typingEl);\n      messages.scrollTop = messages.scrollHeight;\n      return typingEl;\n    }\n  }, {\n    key: "removeTypingIndicator",\n    value: function removeTypingIndicator(typingIndicator) {\n      if (typingIndicator && typingIndicator.parentNode) {\n        typingIndicator.parentNode.removeChild(typingIndicator);\n      }\n    }\n  }, {\n    key: "addMessage",\n    value: function addMessage(text, sender) {\n      var messages = this.chatbotWidget.querySelector(\'[data-chatbot-messages]\');\n      var messageEl = document.createElement(\'div\');\n      messageEl.className = "message ".concat(sender);\n      messageEl.textContent = text;\n      messages.appendChild(messageEl);\n      messages.scrollTop = messages.scrollHeight;\n    }\n  }, {\n    key: "addMessageWithTypingEffect",\n    value: function () {\n      var _addMessageWithTypingEffect = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(text, sender) {\n        var messages, messageEl, i, typeSpeed, typeWriter;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                messages = this.chatbotWidget.querySelector(\'[data-chatbot-messages]\');\n                messageEl = document.createElement(\'div\');\n                messageEl.className = "message ".concat(sender);\n                messages.appendChild(messageEl);\n\n                // Simulate typing effect\n                i = 0;\n                typeSpeed = 30; // Milliseconds per character\n                typeWriter = function typeWriter() {\n                  if (i < text.length) {\n                    var _char = text.charAt(i);\n                    if (_char === \'\\n\') {\n                      _char = \'<br>\';\n                    }\n                    messageEl.innerHTML += _char;\n                    i++;\n                    messages.scrollTop = messages.scrollHeight;\n                    setTimeout(typeWriter, typeSpeed);\n                  }\n                };\n                typeWriter();\n              case 8:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n      function addMessageWithTypingEffect(_x2, _x3) {\n        return _addMessageWithTypingEffect.apply(this, arguments);\n      }\n      return addMessageWithTypingEffect;\n    }()\n  }]);\n  return Messaging;\n}();\n\n//# sourceURL=webpack:///./JavaScript/Frontend/chatbotWidget/messaging.js?')},"./JavaScript/Frontend/chatbotWidget/position.js":
/*!*******************************************************!*\
  !*** ./JavaScript/Frontend/chatbotWidget/position.js ***!
  \*******************************************************/
/*! exports provided: Position */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Position\", function() { return Position; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n// Position Component for MistralChatbot\nvar Position = /*#__PURE__*/function () {\n  function Position(chatbotWidget, storage) {\n    _classCallCheck(this, Position);\n    this.chatbotWidget = chatbotWidget;\n    this.storage = storage;\n  }\n  _createClass(Position, [{\n    key: \"setupDraggable\",\n    value: function setupDraggable() {\n      var _this = this;\n      var header = this.chatbotWidget.querySelector('.chatbot-header');\n      var self = this;\n      var isDragging = false;\n      var offsetX, offsetY;\n\n      // Store initial position to use as reference\n      var initialX, initialY;\n\n      // Function to handle start of drag\n      var startDrag = function startDrag(e) {\n        // Get clientX and clientY based on event type (mouse or touch)\n        var clientX = e.clientX || e.touches[0].clientX;\n        var clientY = e.clientY || e.touches[0].clientY;\n\n        // Prevent dragging only when clicking specific interactive elements\n        if (e.target.getAttribute('data-chatbot-toggle') !== null || e.target.getAttribute('data-chatbot-input') !== null || e.target.getAttribute('data-chatbot-send') !== null) return;\n\n        // Prevent default behavior to avoid text selection during drag start\n        e.preventDefault();\n        isDragging = true;\n\n        // Add no-select class to body to prevent text selection during dragging\n        document.body.classList.add('no-select');\n\n        // Get the current position of the chatbot\n        var rect = _this.chatbotWidget.getBoundingClientRect();\n\n        // Calculate the offset from the mouse/touch position to the chatbot corner\n        offsetX = clientX - rect.left;\n        offsetY = clientY - rect.top;\n\n        // Store initial position\n        initialX = rect.left;\n        initialY = rect.top;\n\n        // Change cursor to indicate dragging\n        if (e.target.closest('.chatbot-header')) {\n          header.style.cursor = 'grabbing';\n        }\n        _this.chatbotWidget.style.cursor = 'grabbing';\n      };\n\n      // Function to handle drag movement\n      var drag = function drag(e) {\n        if (!isDragging) return;\n\n        // Prevent default behavior to avoid text selection during drag\n        e.preventDefault();\n\n        // Get clientX and clientY based on event type (mouse or touch)\n        var clientX = e.clientX || e.touches[0].clientX;\n        var clientY = e.clientY || e.touches[0].clientY;\n\n        // Calculate new position\n        var newX = clientX - offsetX;\n        var newY = clientY - offsetY;\n\n        // Get chatbot dimensions\n        var chatbotWidth = _this.chatbotWidget.offsetWidth;\n        var chatbotHeight = _this.chatbotWidget.offsetHeight;\n\n        // Ensure the chatbot stays within the viewport\n        // Keep at least 50px of the chatbot visible on each edge\n        var minVisiblePart = 50;\n\n        // Check right edge\n        if (newX + chatbotWidth < minVisiblePart) {\n          newX = minVisiblePart - chatbotWidth;\n        }\n\n        // Check bottom edge\n        if (newY + chatbotHeight < minVisiblePart) {\n          newY = minVisiblePart - chatbotHeight;\n        }\n\n        // Check left edge\n        if (newX > window.innerWidth - minVisiblePart) {\n          newX = window.innerWidth - minVisiblePart;\n        }\n\n        // Check top edge\n        if (newY > window.innerHeight - minVisiblePart) {\n          newY = window.innerHeight - minVisiblePart;\n        }\n\n        // Update position using transform for better performance\n        _this.chatbotWidget.style.transform = \"translate(\".concat(newX - initialX, \"px, \").concat(newY - initialY, \"px)\");\n      };\n\n      // Function to handle end of drag\n      var endDrag = function endDrag() {\n        if (!isDragging) return;\n        isDragging = false;\n\n        // Remove no-select class from body to re-enable text selection\n        document.body.classList.remove('no-select');\n\n        // Reset cursor\n        header.style.cursor = 'grab';\n        _this.chatbotWidget.style.cursor = '';\n\n        // Get the final position after dragging\n        var rect = _this.chatbotWidget.getBoundingClientRect();\n\n        // Calculate the distance from the edges of the viewport\n        var right = window.innerWidth - rect.right;\n        var bottom = window.innerHeight - rect.bottom;\n\n        // Update the chatbot's position using CSS properties\n        _this.chatbotWidget.style.right = right + 'px';\n        _this.chatbotWidget.style.bottom = bottom + 'px';\n        _this.chatbotWidget.style.left = 'auto';\n        _this.chatbotWidget.style.top = 'auto';\n\n        // Reset transform\n        _this.chatbotWidget.style.transform = 'none';\n\n        // Save the position for future page loads\n        self.savePosition(right, bottom);\n      };\n\n      // Mouse events\n      this.chatbotWidget.addEventListener('mousedown', startDrag);\n      document.addEventListener('mousemove', drag);\n      document.addEventListener('mouseup', endDrag);\n\n      // Touch events for mobile support\n      this.chatbotWidget.addEventListener('touchstart', startDrag);\n      document.addEventListener('touchmove', drag, {\n        passive: false\n      });\n      document.addEventListener('touchend', endDrag);\n    }\n  }, {\n    key: \"savePosition\",\n    value: function savePosition(right, bottom) {\n      // Save the position to localStorage using the storage utility\n      this.storage.savePosition(right, bottom);\n    }\n  }, {\n    key: \"loadPosition\",\n    value: function loadPosition() {\n      // Check if we're on a mobile device\n      var isMobile = window.innerWidth <= 480;\n\n      // Try to load the position from localStorage\n      var position = this.storage.loadPosition();\n      if (position && !isMobile) {\n        // Apply the saved position\n        if (position.right !== undefined && position.bottom !== undefined) {\n          this.chatbotWidget.style.right = position.right + 'px';\n          this.chatbotWidget.style.bottom = position.bottom + 'px';\n        }\n      } else if (isMobile) {\n        // Reset position for mobile devices to ensure visibility\n        this.chatbotWidget.style.right = '20px';\n        this.chatbotWidget.style.bottom = '20px';\n        this.chatbotWidget.style.transform = 'none';\n      }\n    }\n  }]);\n  return Position;\n}();\n\n//# sourceURL=webpack:///./JavaScript/Frontend/chatbotWidget/position.js?")},"./JavaScript/Frontend/chatbotWidget/storage.js":
/*!******************************************************!*\
  !*** ./JavaScript/Frontend/chatbotWidget/storage.js ***!
  \******************************************************/
/*! exports provided: Storage */function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Storage", function() { return Storage; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n// Storage Component for MistralChatbot\nvar Storage = /*#__PURE__*/function () {\n  function Storage() {\n    _classCallCheck(this, Storage);\n  }\n  _createClass(Storage, [{\n    key: "savePosition",\n    value: function savePosition(right, bottom) {\n      // Save the position to localStorage\n      localStorage.setItem(\'chatbot-position\', JSON.stringify({\n        right: right,\n        bottom: bottom\n      }));\n    }\n  }, {\n    key: "loadPosition",\n    value: function loadPosition() {\n      // Try to load the position from localStorage\n      var positionStr = localStorage.getItem(\'chatbot-position\');\n      if (positionStr) {\n        try {\n          return JSON.parse(positionStr);\n        } catch (e) {\n          console.error(\'Error loading chatbot position:\', e);\n          return null;\n        }\n      }\n      return null;\n    }\n  }, {\n    key: "saveMinimizedState",\n    value: function saveMinimizedState(isMinimized) {\n      // Save the minimized state to localStorage\n      localStorage.setItem(\'chatbot-minimized\', isMinimized);\n    }\n  }, {\n    key: "loadMinimizedState",\n    value: function loadMinimizedState() {\n      // Load minimized state\n      return localStorage.getItem(\'chatbot-minimized\') === \'true\';\n    }\n  }]);\n  return Storage;\n}();\n\n//# sourceURL=webpack:///./JavaScript/Frontend/chatbotWidget/storage.js?')},"./JavaScript/Frontend/chatbotWidget/ui.js":
/*!*************************************************!*\
  !*** ./JavaScript/Frontend/chatbotWidget/ui.js ***!
  \*************************************************/
/*! exports provided: UI */function(module,__webpack_exports__,__webpack_require__){"use strict";eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UI\", function() { return UI; });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n// UI Component for MistralChatbot\nvar UI = /*#__PURE__*/function () {\n  function UI(chatbotWidget) {\n    _classCallCheck(this, UI);\n    this.chatbotWidget = chatbotWidget;\n    this.setupAutoResize();\n  }\n  _createClass(UI, [{\n    key: \"hideDefaultPrompt\",\n    value: function hideDefaultPrompt() {\n      var defaultPrompt = this.chatbotWidget.querySelector('[data-defaultprompt]');\n      defaultPrompt.classList.add('u-hide');\n    }\n  }, {\n    key: \"setupAutoResize\",\n    value: function setupAutoResize() {\n      var _this = this;\n      var input = this.chatbotWidget.querySelector('[data-chatbot-input]');\n      if (!input) return;\n\n      // Initial resize\n      this.adjustTextareaHeight(input);\n\n      // Resize on input\n      input.addEventListener('input', function () {\n        _this.adjustTextareaHeight(input);\n      });\n\n      // Resize on focus\n      input.addEventListener('focus', function () {\n        _this.adjustTextareaHeight(input);\n      });\n    }\n  }, {\n    key: \"adjustTextareaHeight\",\n    value: function adjustTextareaHeight(textarea) {\n      // Reset height to auto to get the correct scrollHeight\n      textarea.style.height = 'auto';\n\n      // Set the height to match content (scrollHeight)\n      textarea.style.height = textarea.scrollHeight + 'px';\n    }\n  }, {\n    key: \"toggleChat\",\n    value: function toggleChat() {\n      var toggle = this.chatbotWidget.querySelector('[data-chatbot-toggle]');\n      var body = this.chatbotWidget.querySelector('[data-chatbotwidget-body]');\n      if (body.classList.contains('u-hide')) {\n        body.classList.remove('u-hide');\n        toggle.textContent = '−';\n        return false;\n      }\n      body.classList.add('u-hide');\n      toggle.textContent = '+';\n      return true;\n    }\n  }, {\n    key: \"setupResizeHandler\",\n    value: function setupResizeHandler() {\n      var _this2 = this;\n      // Add resize event listener to handle window size changes\n      window.addEventListener('resize', function () {\n        // Check if we're on a mobile device after resize\n        var isMobile = window.innerWidth <= 480;\n        if (isMobile) {\n          // Reset position for mobile devices to ensure visibility\n          _this2.chatbotWidget.style.right = '20px';\n          _this2.chatbotWidget.style.bottom = '20px';\n          _this2.chatbotWidget.style.transform = 'none';\n        }\n      });\n    }\n  }]);\n  return UI;\n}();\n\n//# sourceURL=webpack:///./JavaScript/Frontend/chatbotWidget/ui.js?")}});